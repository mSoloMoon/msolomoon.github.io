<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>拜读Bruce大作 —— 《Java编程思想》(第一遍) | 月光独奏</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="所有优秀的作者，包括那些编写软件的程序员，都清楚其著作的某些部分直至重新创作的时候才变得完美，有时甚至要反复重写多次。

第一章 对象导论

对象是一个通过对问题域(即上下文)中的元素进行建模，是一个其封装了以数据成员或属性表示的内部状态和以成员方法与接口表示的行为的抽象概念。

对象始于抽象 -&gt; 抽象始于问题建模【问题域即上下文】；
每个对象都有一个接口，接口体现服务，每个对象都提">
<meta property="og:type" content="article">
<meta property="og:title" content="拜读Bruce大作 —— 《Java编程思想》(第一遍)">
<meta property="og:url" content="http://yoursite.com/2014/11/05/reading-bruce-thinking-in-java/">
<meta property="og:site_name" content="月光独奏">
<meta property="og:description" content="所有优秀的作者，包括那些编写软件的程序员，都清楚其著作的某些部分直至重新创作的时候才变得完美，有时甚至要反复重写多次。

第一章 对象导论

对象是一个通过对问题域(即上下文)中的元素进行建模，是一个其封装了以数据成员或属性表示的内部状态和以成员方法与接口表示的行为的抽象概念。

对象始于抽象 -&gt; 抽象始于问题建模【问题域即上下文】；
每个对象都有一个接口，接口体现服务，每个对象都提">
<meta property="og:image" content="https://msolomoon.github.io/images/bookcover_bruce_thinking_in_java.jpg">
<meta property="og:image" content="https://msolomoon.github.io/images/class_file_run_in_jvm.png">
<meta property="og:image" content="https://msolomoon.github.io/images/Java_full_container_taxonomy.JPG">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="拜读Bruce大作 —— 《Java编程思想》(第一遍)">
<meta name="twitter:description" content="所有优秀的作者，包括那些编写软件的程序员，都清楚其著作的某些部分直至重新创作的时候才变得完美，有时甚至要反复重写多次。

第一章 对象导论

对象是一个通过对问题域(即上下文)中的元素进行建模，是一个其封装了以数据成员或属性表示的内部状态和以成员方法与接口表示的行为的抽象概念。

对象始于抽象 -&gt; 抽象始于问题建模【问题域即上下文】；
每个对象都有一个接口，接口体现服务，每个对象都提">

  
    <link rel="alternative" href="/atom.xml" title="月光独奏" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">

  <script src="http://libs.baidu.com/jquery/1.9.0/jquery.js"></script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<div class="profilepic">
			<img src="http://msolo-programmer.qiniudn.com/msolo_me_square.png">
		</div>

		<hgroup>
		  <h1 class="header-author"><a href="/">月光独奏</a></h1>
		</hgroup>

		
		<p class="header-subtitle">软件设计及开发者</p>
		

		
			<div class="onoffswitch">
			    <input type="checkbox" name="onoffswitch" class="onoffswitch-checkbox" id="myonoffswitch" checked>
			    <label class="onoffswitch-label" for="myonoffswitch">
			        <span class="onoffswitch-inner"></span>
			        <span class="onoffswitch-switch"></span>
			    </label>
			</div>
		

		<div class="switch-area">
			<section class="first-part">
				<nav class="header-menu">
					<ul>
					
						<li><a href="/">主页</a></li>
			        
						<li><a href="/archives">所有文章</a></li>
			        
						<li><a href="/categories/随笔">随笔</a></li>
			        
						<li><a href="/categories/摘录">摘录</a></li>
			        
						<li><a href="/categories/书籍">书籍</a></li>
			        
						<li><a href="/categories/Web">Web</a></li>
			        
						<li><a href="/categories/C-Cpp-Go">C/Cpp/Go</a></li>
			        
						<li><a href="/categories/java-android">Java/Android</a></li>
			        
						<li><a href="/categories/project">Project</a></li>
			        
						<li><a href="/categories/程序员日志">程序员日志</a></li>
			        
						<li><a href="/about">关于</a></li>
			        
					</ul>
				</nav>
				<nav class="header-nav">
					<div class="social">
						
							<a class="github" target="_blank" href="https://github.com/mSoloMoon" title="github">github</a>
				        
							<a class="weibo" target="_blank" href="http://t.qq.com/zhengguangyu_msolo" title="weibo">weibo</a>
				        
							<a class="email" target="_blank" href="mailto://yuezhi.msolo@outlook.com" title="email">email</a>
				        
							<a class="qq" target="_blank" href="/212499714" title="qq">qq</a>
				        
					</div>
				</nav>
			</section>
			
			
			<section class="second-part">
				<div class="widget tagcloud">
					<a href="/tags/Android/" style="font-size: 13.75px;">Android</a><a href="/tags/C-C/" style="font-size: 11.25px;">C/C++</a><a href="/tags/Go/" style="font-size: 11.25px;">Go</a><a href="/tags/IT问题录/" style="font-size: 11.25px;">IT问题录</a><a href="/tags/IT面试/" style="font-size: 16.25px;">IT面试</a><a href="/tags/Java/" style="font-size: 12.50px;">Java</a><a href="/tags/Java-Web/" style="font-size: 11.25px;">Java Web</a><a href="/tags/书籍笔记/" style="font-size: 10.00px;">书籍笔记</a><a href="/tags/历史/" style="font-size: 11.25px;">历史</a><a href="/tags/哲学/" style="font-size: 11.25px;">哲学</a><a href="/tags/思考/" style="font-size: 13.75px;">思考</a><a href="/tags/持续部署/" style="font-size: 11.25px;">持续部署</a><a href="/tags/摘录/" style="font-size: 15.00px;">摘录</a><a href="/tags/生活记录/" style="font-size: 17.50px;">生活记录</a><a href="/tags/软件开发/" style="font-size: 20.00px;">软件开发</a><a href="/tags/软件框架/" style="font-size: 12.50px;">软件框架</a><a href="/tags/软件调试/" style="font-size: 11.25px;">软件调试</a><a href="/tags/金融/" style="font-size: 11.25px;">金融</a><a href="/tags/随笔/" style="font-size: 18.75px;">随笔</a><a href="/tags/项目/" style="font-size: 12.50px;">项目</a>
				</div>
			</section>
			
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay"></div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img src="http://msolo-programmer.qiniudn.com/msolo_me_square.png">
			</div>

			<hgroup>
			  <h1 class="header-author"><a href="/">月光独奏</a></h1>
			</hgroup>
			
			<p class="header-subtitle">软件设计及开发者</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/categories/随笔">随笔</a></li>
		        
					<li><a href="/categories/摘录">摘录</a></li>
		        
					<li><a href="/categories/书籍">书籍</a></li>
		        
					<li><a href="/categories/Web">Web</a></li>
		        
					<li><a href="/categories/C-Cpp-Go">C/Cpp/Go</a></li>
		        
					<li><a href="/categories/java-android">Java/Android</a></li>
		        
					<li><a href="/categories/project">Project</a></li>
		        
					<li><a href="/categories/程序员日志">程序员日志</a></li>
		        
					<li><a href="/about">关于</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/mSoloMoon" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://t.qq.com/zhengguangyu_msolo" title="weibo">weibo</a>
			        
						<a class="email" target="_blank" href="mailto://yuezhi.msolo@outlook.com" title="email">email</a>
			        
						<a class="qq" target="_blank" href="/212499714" title="qq">qq</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <article id="post-reading-bruce-thinking-in-java" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/11/05/reading-bruce-thinking-in-java/" class="article-date">
  	<time datetime="2014-11-05T06:38:44.000Z" itemprop="datePublished">11月 5 2014</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/书籍/">书籍</a>
  </div>

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/摘录/">摘录</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/软件开发/">软件开发</a></li></ul>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      拜读Bruce大作 —— 《Java编程思想》(第一遍)
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://msolomoon.github.io/images/bookcover_bruce_thinking_in_java.jpg" alt="Java编程思想"></p>
<p><br></p>
<blockquote>
<p><strong>所有优秀的作者，包括那些编写软件的程序员，都清楚其著作的某些部分直至重新创作的时候才变得完美，有时甚至要反复重写多次</strong>。</p>
</blockquote>
<h3 id="第一章_对象导论">第一章 对象导论</h3>
<blockquote>
<p><strong>对象是一个通过对问题域(即上下文)中的元素进行建模，是一个其封装了以数据成员或属性表示的内部状态和以成员方法与接口表示的行为的抽象概念</strong>。</p>
<ol>
<li>对象始于抽象 -&gt; 抽象始于问题建模【问题域即上下文】；</li>
<li><strong>每个对象都有一个接口，接口体现服务，每个对象都提供服务，将对象看作“服务的提供者”有助于提高对象的内聚性；</strong></li>
<li>使用面向对象的好处：便于对问题进行表示和交流；可应用设计良好的继承机制；拥有比如多态(可替代性(substitutability)：某一特定类型的所有对象都可以接收同样的消息)等高级开发技巧；</li>
</ol>
</blockquote>
<ul>
<li>继承关系探讨，“是一个” 与 “像是一个”，【书：有时必须在导出类型中添加新的接口元素，这个新的类型仍然可以替代基类，但是这种替代并不完美，因为基类无法访问新添加的方法。这种情况我们可以描述为is-like-a关系。】</li>
<li>多态的可互换对象，【书：为了执行动态绑定，Java使用一小段特殊代码来替代绝对地址调用；它忽略类型的具体细节，仅仅和基类交互。这段代码和具体类型信息是分离的…把将导出类看做是它的基类的过程称为向上转型(upcasting)…这里要表达的是，如果你是一个Shape，我知道你可以 erase() 和 draw() 你自己，那么去做吧…】</li>
<li>单根继承结构的好处：1.简化参数传递，保证所有对象都具有某些功能，执行基本操作；2.使得垃圾回收器的实现变得容易多；3.为异常处理等系统级操作带来灵活性；</li>
<li>异常处理：异常是一种对象；有助于编写出更健壮程序的机制；</li>
</ul>
<h3 id="第二章_一切都是对象">第二章 一切都是对象</h3>
<blockquote>
<p>一切都是引用，引用操纵对象；<br>对象存储到什么地方：new 对象存储在堆（寄存器、堆栈、堆、常量存储区、非RAM存储区[流对象和持久化对象-即磁盘等]）；<br>基本类型存储到什么地方：变量直接存储“值”，并置于堆栈中，更加高效；<br>java中的数组，【书：当创建一个数组对象时，实际上就是创建一个引用数组。并且每个引用都会被初始化为一个特定值，该值拥有自己的关键字null】；</p>
</blockquote>
<ul>
<li><strong>永远不需要销毁对象?!</strong></li>
<li>static 关键字：static 方法可以创建或使用与其类型相同的被命名对象；因此常常拿来做“牧羊人”的角色，负责看护与其隶属统一类型的实例群；</li>
</ul>
<a id="more"></a>

<h3 id="第三章_操作符">第三章 操作符</h3>
<p><br></p>
<h3 id="第四章_控制执行流程">第四章 控制执行流程</h3>
<p><br></p>
<h3 id="第五章_初始化与清理">第五章 初始化与清理</h3>
<blockquote>
<p>初始化和清理是涉及安全的两个问题。</p>
</blockquote>
<ul>
<li>用构造器确保初始化，【书：在Java中，“初始化”和“创建”捆绑在一起，两者不可分离】;</li>
<li>方法重载：每个重载的方法都必须有一个独一无二的参数类型列表(尽管参数顺序不同也是被允许的，但会带来代码的混乱使得程序难以维护)；另外，只要编译器可以根据语境判断出语义，那么就可以使用返回值区分重载方法(但通常不采用此做法)；</li>
<li>在构造器中调用构造器：尽管可以用this调用一个构造器，但却不能调用两个；此外，必须将构造器调用置于最起始处，否则编译器会报错。</li>
<li>static 的含义，static 方法就是没有this 的方法。</li>
<li><strong>清理, 终结处理和垃圾回收：在 java 中，对象可能不被垃圾回收；垃圾回收并不等于“析构”。看来之所以要有finalize()，是由于在分配内存时可能采用了类似C语言中的做法，而非 java 中的通常做法。这种情况主要发生在使用“本地方法”的情况下</strong>。</li>
<li>只要对象中存在没有被适当清理的部分，程序就存在很隐晦的缺陷。(近来，在某些情况下，单例模式也被认为有此问题。)</li>
</ul>
<p><img src="https://msolomoon.github.io/images/class_file_run_in_jvm.png" alt="class文件在JVM中的视图"></p>
<blockquote>
<p>JVM - 类加载器</p>
<ol>
<li>bootstrap class loader（引导类加载器）：是其他类加载器的父类，它用于加载Java核心库，并且是唯一一个用本地代码编写的类加载器。</li>
<li>extension class loader（扩展类加载器）：是bootstrap class loader加载器的子类，用于加载扩展库。</li>
<li>system class loader（系统类加载器）：是extension class loader加载器的子类，用于加载在classpath中的应用程序的类文件。</li>
<li>user-defined class loader（用户定义的类加载器）：是系统类加载器或其他用户定义的类加载器的子类。 </li>
</ol>
</blockquote>
<hr>
<blockquote>
<p><a href="http://www.importnew.com/13504.html" target="_blank" rel="external">Java GC系列（1）：Java垃圾回收简介</a><br>在JVM体系结构中，与垃圾回收相关的两个主要组件是堆内存和垃圾回收器。堆内存用来保存运行时的对象实例。<br>堆内存有以下三个主要区域：</p>
<ol>
<li>新生代（Young Generation）<br>Eden空间（Eden space，任何实例都通过Eden空间进入运行时内存区域）<br>S0 Survivor空间（S0 Survivor space，存在时间长的实例将会从Eden空间移动到S0 Survivor空间）<br>S1 Survivor空间 （存在时间更长的实例将会从S0 Survivor空间移动到S1 Survivor空间）</li>
<li>老年代（Old Generation）实例将从S1提升到Tenured（终身代）</li>
<li>永久代（Permanent Generation）包含类、方法等细节的元信息。(在Java SE8特性中已经被移除)</li>
</ol>
</blockquote>
<hr>
<blockquote>
<p><strong>垃圾回收器如何工作？</strong></p>
<ol>
<li>当它工作时，将一面回收空间，一面使堆中的对象紧凑排列，这样“堆指针”可以很容易移动到更靠近“传送带”的开始处，也就尽量避免了页面错误。</li>
<li>引用计数是一种简单但速度很慢的垃圾回收技术。这种方法有个缺陷，如果对象之间存在循环引用，可能会出现“对象应该被回收，但引用计数却不为零”的情况。对垃圾回收器来说，定位这样的交互自引用的对象组所需的工作量极大。</li>
<li>在一些更快的模式中，垃圾回收器并非基于引用计数。它们依据的思想是：对任何“活”的对象，一定能最终追溯到其存活在堆栈或静态存储区之中的引用。在这种方式下，Java虚拟机将采用一种自适应的垃圾回收技术。至于如何处理找到的存活对象，取决于不同的Java虚拟机实现。有一种做法名为stop-and-copy。显然，这意味着，先暂停程序的运行（所以它不属于后台回收模式），然后将所有存活的对象从当前堆复制到另一个堆，没有被复制的全部都是垃圾。复制式回收器仍然会将所有内存自一处复制到另一处，这很浪费。为了避免这种情形，一些虚拟机会进行检查：钥匙没有新垃圾产生，就会转换到另一种工作模式（即“自适应”）。这种模式称为标记-清扫（mark-and-sweep），只有全部标记工作完成的时候，清理工作才会开始。没有标记的对象将被释放，不会发生任复制动作。所以省下的堆空间是不连续的。</li>
<li>内存分配以较大的“块”为单位。如果对象较大，它会单占用单独的块。每个块都用相应的代数来记录它是否还存活。通常，如果块在某处被引用，其代数会增加；大型对象仍然不会被复制（只是其代数会增加）。<br><strong>5. Java虚拟机会进行监视，如果所有对象都很稳定，垃圾回收器的效率降低的话，就切换到“标记-清扫”方式；同样，Java虚拟机会跟踪“标记-清扫”的效果，要是堆空间出现很多碎片，就会切换回“停止-复制”方式。这就是“自适应”技术。</strong></li>
</ol>
</blockquote>
<ul>
<li>构造器初始化：初始化顺序（在类的内部，变量定义的先后顺序决定了初始化的顺序，即使变量定义散布于方法定义之间，它们仍旧会在任何方法(包括构造器)被调用之前得到初始化，先是静态对象，然后是“非静态”对象）。</li>
</ul>
<blockquote>
<p><strong>对象的创建过程（假设有个名为Dog的类）：</strong></p>
<ol>
<li>即使没有显式地使用static关键字，构造器实际上也是静态方法（或者可看成静态方法）。因此，当首次创建类型为Dog的对象时，或者Dog类的静态方法/静态域首次被访问时，Java解释器必须查找类路径，以定位Dog.class文件；</li>
<li>然后载入Dog.class，有关静态初始化的所有动作都会执行。因此，静态初始化只在Class对象首次加载的时候进行一次；</li>
<li>当用new创建对象的时候，首先将在堆上位Dog对象分配足够的存储空间；</li>
<li>这块存储空间会被清零，这就自动地将Dog对象中的所有基本类型数据都设置成了默认值，而引用则被设置成了null；</li>
<li>执行所有出现于字段定义处的初始化动作；</li>
<li>执行构造器；</li>
</ol>
</blockquote>
<h3 id="第六章_访问权限控制">第六章 访问权限控制</h3>
<ul>
<li>Java 访问权限修饰词：包访问权限（无关键字，默认）；public（接口访问权限）；private（私有）；protected（继承访问权限，同时也具有包访问权限）；</li>
<li>访问权限控制可以确保不会有任何客户端程序员依赖于某个类的底层实现的任何部分；另外，严格地遵循访问权限控制并不一定是最佳选择；</li>
</ul>
<h3 id="第七章_复用类">第七章 复用类</h3>
<ul>
<li>初始化基类：【书：当创建一个导出类的对象时，该对象包含了一个基类的子对象…Java会自动在导出类的构造器中插入对基类构造器的调用。】，（super 关键字）</li>
<li>对接口进行编程，优先考虑组合；</li>
<li><strong>空白final：可做到根据对象而有所不同，却又保持其恒定不变的特性；</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlankFinal</span> </span>{</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> j; 		<span class="comment">// blank final</span></div><div class="line">	<span class="keyword">private</span> fianl Poppet p;		<span class="comment">// blank final reference</span></div><div class="line">	<span class="keyword">public</span> <span class="title">BlankFinal</span>() {	j = <span class="number">1</span>; p = <span class="keyword">new</span> Poppet(<span class="number">1</span>); }</div><div class="line">	<span class="keyword">public</span> <span class="title">BlankFinal</span>(<span class="keyword">int</span> x) { j = x; p = <span class="keyword">new</span> Poppet(x); }</div><div class="line">}</div></pre></td></tr></table></figure>

<ul>
<li>final参数：无法在方法中更改参数引用所指向的对象；</li>
<li>类中所有的 private() 方法都隐式地指定为是final。</li>
</ul>
<h3 id="第八章_多态">第八章 多态</h3>
<blockquote>
<p>“封装”通过合并特征和行为来创建新的类型。“实现隐藏”则通过将细节“私有化”把接口和实现分离开来。而多态的作用是消除类型之间的耦合关系。<br><strong>多态通过分离做什么和怎么做，从另一角度将接口和实现分离开来。</strong></p>
</blockquote>
<ul>
<li>【<strong>书：在这里，Stage对象包含一个对Actor的引用，而Actor被初始化为HappyActor对象。这意味着performPlay()会产生某种特殊行为。既然引用在运行时可以与另一个不同的对象重新绑定起来，所以SadActor对象的引用可以在actor中被替代，然后由performPlay()产生的行为也随之改变。这样一来，程序在运行期间获得了动态灵活性（这也称作状态模式）</strong>】</li>
<li>纯继承与扩展，【书：因为只要开始考虑，就会转向，并发现扩展接口才是解决特定问题的完美方案…一旦向上转型，就不能调用那些新方法。】</li>
<li>向下转型与运行时类型识别(RTTI)，如果所转类型是正确的类型，那么转型成功，否则就会返回一个ClassCastException异常。</li>
</ul>
<h3 id="第九章_接口">第九章 接口</h3>
<ul>
<li><strong>抽象类和抽象方法：为它的所有导出类创建一个通用接口；抽象类还是很有用的重构工具，因为它们使得我们可以很容易地将公共方法沿着继承层次结构向上移动</strong>；</li>
<li>完全解耦：【书：只要一个方法操作的是类而非接口，那么你就只能使用这个类及其子类。如果你想要将这个方法应用于不在此继承结构中的某个类…则接口可以在很大程度上放宽这种限制，因此，它使得我们可编写可复用性更好的代码。】</li>
<li><strong>策略设计模式：创建一个能够根据所传递的参数对象的不同而具有不同行为的方法。这类方法包含所要执行的算法中固定不变的部分，而“策略”包含变化的部分；策略就是传递进去的参数对象。下面，Processor对象就是一个策略；可以看到有两种策略应用到了String类型的s对象上。</strong>（P175）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">class Processor {</div><div class="line">	<span class="keyword">public</span> String <span class="title">name</span>() { <span class="keyword">return</span> getClass().getSimpleName(); }</div><div class="line">	Object process(Object input) { <span class="keyword">return</span> input; }</div><div class="line">}</div><div class="line">class Upcase extends Processor {</div><div class="line">	String process(Object input) { <span class="keyword">return</span> ((String)input).toUpperCase(); }</div><div class="line">}</div><div class="line">class Downcase extends Processor {</div><div class="line">	String process(Object input) { <span class="keyword">return</span> ((String)input).toLowerCse(); }</div><div class="line">}</div><div class="line"><span class="keyword">public</span> Class Apply {</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span>(Processor p, Object s) {		<span class="comment">// 太耦合</span></div><div class="line">		...</div><div class="line">	}</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String s = <span class="string">"Disagreement with ..."</span>;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">		process(<span class="keyword">new</span> Upcase(), s);</div><div class="line">		process(<span class="keyword">new</span> Downcase(), s);</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<ul>
<li>通过继承来扩展接口，并尽量避免命名的冲突；</li>
<li>适配接口，通过使用interface关键字提供的伪多重继承机制，我们既可以是A类又可以是B类的新类；</li>
<li>接口中的域，放入接口中的任何域都自动是static和final的；</li>
<li>嵌套接口？</li>
<li>接口与工厂，【书：我们在工厂对象上调用的是创建方法，而该工厂对象将生成接口的某个实现的对象。】</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">interface Service { </div><div class="line">	<span class="keyword">void</span> method1(); </div><div class="line">	<span class="keyword">void</span> method2(); </div><div class="line">}</div><div class="line">interface ServiceFactory { Service getService(); }</div><div class="line">class Implementation1 implements Service {</div><div class="line">	Implementation1();</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span>();</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span>();</div><div class="line">}</div><div class="line">class Implementation1Factory implements ServiceFactory {</div><div class="line">	<span class="keyword">public</span> Service <span class="title">getService</span>() {</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Implementation1();</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="第十章_内部类">第十章 内部类</h3>
<ul>
<li>内部类看起来就像一种代码隐藏机制，除此，内部类还能了解外围类，并与之通信；</li>
<li>链接到外部类，可以使用外部类的名字后面紧跟圆点和this；</li>
<li>.new语法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DotNew</span> </span>{</div><div class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span>() </span>{}</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String args) {</div><div class="line">		DotNew dn = <span class="keyword">new</span> DotNew();</div><div class="line">		DotNew.Inner dni = dn.<span class="keyword">new</span> Inner();</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<ul>
<li>内部类给类的设计者提供了一种途径，通过这种方式可以完全阻止任何依赖于类型的编码，并且完全隐藏了实现的细节；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">class Parcel4 {</div><div class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">PContents</span> <span class="keyword">implements</span> <span class="title">Contents</span> </span>{</div><div class="line">		<span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</div><div class="line">		<span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span>() { <span class="keyword">return</span> i; }</div><div class="line">	}</div><div class="line">	<span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">PDestination</span> <span class="keyword">implements</span> <span class="title">Destination</span> </span>{</div><div class="line">		<span class="keyword">private</span> String label;</div><div class="line">		<span class="keyword">private</span> <span class="title">PDestination</span>(String whereTo) { label = whereTo }</div><div class="line">		<span class="keyword">public</span> String <span class="title">readLabel</span>() { <span class="keyword">return</span> label; }</div><div class="line">	}</div><div class="line">	<span class="keyword">public</span> Destination <span class="title">destination</span>(String s) { <span class="keyword">return</span> <span class="keyword">new</span> PDestination(s); }</div><div class="line">	<span class="keyword">public</span> Contents <span class="title">contents</span>() { <span class="keyword">return</span> <span class="keyword">new</span> PContents(); } </div><div class="line">}</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestParcel</span> </span>{</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">		Parcel4 p = <span class="keyword">new</span> Parcel4();</div><div class="line">		Contents c = p.contents();</div><div class="line">		Destination d = p.destination(<span class="string">"Tasmania"</span>);</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<ul>
<li>匿名内部类与工厂方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">interface Service { </div><div class="line">	<span class="keyword">void</span> method1(); </div><div class="line">	<span class="keyword">void</span> method2(); </div><div class="line">}</div><div class="line">interface ServiceFactory { Service getService(); }</div><div class="line">class Implementation1 implements Service {</div><div class="line">	<span class="keyword">private</span> <span class="title">Implementation1</span>();</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span>() { print(<span class="string">"Implementation1 method1"</span>); }</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span>() { print(<span class="string">"Implementation1 method2"</span>); }</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> ServiceFactory factory = </div><div class="line">		<span class="keyword">new</span> ServiceFactory() {</div><div class="line">			<span class="keyword">public</span> <span class="title">ServiceFactory</span>() {</div><div class="line">				<span class="keyword">return</span> <span class="keyword">new</span> Implementation1();</div><div class="line">			}</div><div class="line">		}</div><div class="line">}</div></pre></td></tr></table></figure>

<ul>
<li>接口内部的类</li>
</ul>
<blockquote>
<p><strong>为什么需要内部类?</strong><br>如果没有内部类提供的、可以继承多个具体的或抽象的类的能力，一些设计与编程问题就很难解决。从这个角度看，内部类使得多重继承的解决方案变得完整。<br>接口解决了部分问题，而内部类有效地实现了“多重继承”。即内部类允许继承多个非接口类型（类或抽象类）</p>
</blockquote>
<ul>
<li>闭包与回调: 通过内部类提供闭包的功能是优良的解决方案，它比指针更灵活、更安全。</li>
</ul>
<blockquote>
<p>内部类与控制框架（一类特殊的应用程序框架，用来解决响应事件的需求。主要用来响应事件的系统被称作事件驱动系统。）<br>请考虑这样一个控制框架，它的工作就是在事件“就绪”的时候执行事件。虽然“就绪”可以指任何事，但在本例中是指基于时间触发的事件。控制框架并不包含任何具体的信息。那些信息在实现算法的action()部分时，通过继承来提供：<br>首先，接口描述了要控制的事件。因为其默认的行为是基于时间去执行控制，所以使用抽象类代替实际的接口。<br>控制框架的完整实现是由单个的类创建的，从而使得实现的细节被封装起来；内部类用来表示解决问题所必需的各种不同的action()； </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Event</span> </span>{</div><div class="line">	<span class="keyword">private</span> <span class="keyword">long</span> eventTime;</div><div class="line">	<span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">long</span> delayTime;</div><div class="line">	<span class="keyword">public</span> <span class="title">Event</span>(<span class="keyword">long</span> delayTime) {</div><div class="line">		<span class="keyword">this</span>.delayTime = delayTime;</div><div class="line">		start();</div><div class="line">	}</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span>() { eventTime = System.nanoTime() + delayTime; }</div><div class="line">	<span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">ready</span>() { <span class="keyword">return</span> System.nanoTime() &gt;= eventTime; }</div><div class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">action</span>();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreenhouseControls</span> <span class="keyword">extends</span> <span class="title">Controller</span> </span>{</div><div class="line">	...</div><div class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightOn</span> <span class="keyword">extends</span> <span class="title">Event</span> </span>{</div><div class="line">		...</div><div class="line">	}</div><div class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightOff</span> <span class="keyword">extends</span> <span class="title">Event</span> </span>{</div><div class="line">		...</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<ul>
<li>内部类的继承</li>
<li>内部类可以被覆盖吗？（实际上，“覆盖”后的内部类是完全独立的两个实体，各自在自己的命名空间内。）</li>
<li>局部内部类（典型的方式是在方法体里面创建）</li>
<li>内部类标识（OuterClass$InnerClass）</li>
</ul>
<h3 id="第十一章_持有对象">第十一章 持有对象</h3>
<blockquote>
<p>Java容器类库的用途是“保存对象”。<br>新程序中不应该使用过时的Vector、Hashtable和Stack。</p>
</blockquote>
<p><img src="https://msolomoon.github.io/images/Java_full_container_taxonomy.JPG" alt="Java容器全息图"></p>
<h3 id="第十二章_通过异常处理错误">第十二章 通过异常处理错误</h3>
<blockquote>
<p>异常使得我们可以将每件事都当作一个事务来考虑。</p>
</blockquote>
<ul>
<li>举一个抛出异常的简单例子。对于对象引用t，传给你的时候可能尚未被初始化。所以在使用这个对象引用调用其方法之前，会先对引用进行检查。可以创建一个代表错误信息的对象，并且将它从当前环境中“抛出”，这样就把错误信息传播到了“更大”的环境中。这被称为抛出一个异常。</li>
<li>捕获异常 -&gt; 监控区域(try-catch)：一段可能产生异常的代码，并且后面跟着处理这些异常的代码。</li>
<li>终止与恢复：长久以来，尽管程序员们使用的操作系统支持恢复模型的异常处理，但他们最终还是转向使用类似“终止模型”的代码，并且忽略恢复行为。所以虽然恢复模型开始显得很吸引人，但不是很实用。其中的主要原因可能是它所导致的耦合。</li>
<li>异常说明：使用关键字throws，后面接一个所有潜在异常类型的列表。</li>
<li>不过还是有个能“作弊”的地方：可以声明方法将抛出异常，实际上却不抛出。编译器相信了这个声明，并强制此方法的用户像针的抛出异常那样使用这个方法。这样做的好处是，为异常先占个位子，以后就可以抛出这种异常而不用修改已有的代码。在定义抽象基类和接口时，这种能力很重要。</li>
<li>异常链：在捕获一个异常后抛出另一个异常，并且希望把原始异常的信息保存下来，这被称为异常链。有趣的是，在Throwable的子类中，只有三种基本的异常类提供了带cause参数的构造器。它们是Error、Exception以及RuntimeException。如果要把其他类型的异常链接起来，应该使用initCause()方法而不是构造器。</li>
<li>用finally子句进行清理。</li>
<li>对于在构造阶段可能会抛出异常，并且要求清理的类，最安全的使用方式是使用嵌套的try子句。</li>
<li>抛出异常的时候，异常处理系统会按照代码的书写顺序找出“最近”的处理程序。找到匹配的处理程序之后，它就认为异常将得到处理，然后就不再继续查找。</li>
</ul>
<blockquote>
<p><strong>异常使用指南</strong></p>
<ol>
<li>在恰当的级别处理问题。（在知道该如何处理的情况下才捕获异常）</li>
<li>解决问题并且重新调用产生异常的方法。</li>
<li>进行少许修补，然后绕过异常发生的地方继续执行。</li>
<li>用别的数据进行计算，以代替方法预计会返回的值。</li>
<li>把当前运行环境下能做的事情尽量做完，然后把相同的异常重抛到更高层。</li>
<li>把当前运行环境下能做的事情尽量做完，然后把不同的异常抛到更高层。</li>
<li>终止程序。</li>
<li>进行简化，让类库和程序更安全。</li>
</ol>
</blockquote>
<h3 id="第十三章_字符串">第十三章 字符串</h3>
<p><br></p>
<h3 id="第十四章_类型信息">第十四章 类型信息</h3>
<blockquote>
<p>迄今为止，已知的RTTI形式包括：</p>
<ol>
<li>传统的类型转换；</li>
<li>代表对象的类型的Class对象。通过查询Class对象可获取运行时所需的信息；</li>
<li>关键字instanceof。</li>
</ol>
</blockquote>
<ul>
<li>反射：运行时的类信息；</li>
<li>代理</li>
<li>空对象</li>
<li>接口与类型信息：interface关键字的一种重要目标就是允许程序员隔离构件，进而降低耦合性。但是通过类型信息，这种耦合性还是会传播出去，接口并非是对解耦的一种无懈可击的保障。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class C implements A {</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span>() { ... }</div><div class="line">}</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HiddenC</span> </span>{</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> A <span class="title">makeA</span>() {</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> C();</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="第十五章_泛型">第十五章 泛型</h3>

      
    </div>
    <footer class="article-footer">
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2014/11/05/life-daily-log-141105/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">&lt;</strong>
      <div class="article-nav-title">
        
          生活点滴 - 20141105
        
      </div>
    </a>
  
  
    <a href="/2014/11/05/java-interview-part-ii/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Java 面试题 - Stack and Queue</div>
      <strong class="article-nav-caption">&gt;</strong>
    </a>
  
</nav>

  
</article>


<div class="share">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到：</span>
		<a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
		<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>



<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="reading-bruce-thinking-in-java" data-title="拜读Bruce大作 —— 《Java编程思想》(第一遍)" data-url="http://yoursite.com/2014/11/05/reading-bruce-thinking-in-java/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2014 月光独奏
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">

  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>

  <script src="/js/main.js" type="text/javascript"></script>


  </div>
</body>
</html>