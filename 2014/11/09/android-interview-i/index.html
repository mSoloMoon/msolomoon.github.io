<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Android 面试题纪录 | 月光独奏</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1. JVM和DVM的不同

JVM is a stack-based machine; while DVM is register-based;
A stack-based virtual machine must transfer data from registers to the operand stack before manipulating them. In contrast, a">
<meta property="og:type" content="article">
<meta property="og:title" content="Android 面试题纪录">
<meta property="og:url" content="http://yoursite.com/2014/11/09/android-interview-i/">
<meta property="og:site_name" content="月光独奏">
<meta property="og:description" content="1. JVM和DVM的不同

JVM is a stack-based machine; while DVM is register-based;
A stack-based virtual machine must transfer data from registers to the operand stack before manipulating them. In contrast, a">
<meta property="og:image" content="https://msolomoon.github.io/images/IPC_through_Binder.png">
<meta property="og:image" content="https://msolomoon.github.io/images/AIDL_remote _procedure.png">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android 面试题纪录">
<meta name="twitter:description" content="1. JVM和DVM的不同

JVM is a stack-based machine; while DVM is register-based;
A stack-based virtual machine must transfer data from registers to the operand stack before manipulating them. In contrast, a">

  
    <link rel="alternative" href="/atom.xml" title="月光独奏" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">

  <script src="http://libs.baidu.com/jquery/1.9.0/jquery.js"></script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<div class="profilepic">
			<img src="http://msolo-programmer.qiniudn.com/msolo_me_square.png">
		</div>

		<hgroup>
		  <h1 class="header-author"><a href="/">月光独奏</a></h1>
		</hgroup>

		
		<p class="header-subtitle">软件设计及开发者</p>
		

		
			<div class="onoffswitch">
			    <input type="checkbox" name="onoffswitch" class="onoffswitch-checkbox" id="myonoffswitch" checked>
			    <label class="onoffswitch-label" for="myonoffswitch">
			        <span class="onoffswitch-inner"></span>
			        <span class="onoffswitch-switch"></span>
			    </label>
			</div>
		

		<div class="switch-area">
			<section class="first-part">
				<nav class="header-menu">
					<ul>
					
						<li><a href="/">主页</a></li>
			        
						<li><a href="/archives">所有文章</a></li>
			        
						<li><a href="/categories/随笔">随笔</a></li>
			        
						<li><a href="/categories/摘录">摘录</a></li>
			        
						<li><a href="/categories/书籍">书籍</a></li>
			        
						<li><a href="/categories/Web">Web</a></li>
			        
						<li><a href="/categories/C-Cpp-Go">C/Cpp/Go</a></li>
			        
						<li><a href="/categories/java-android">Java/Android</a></li>
			        
						<li><a href="/categories/project">Project</a></li>
			        
						<li><a href="/categories/程序员日志">程序员日志</a></li>
			        
						<li><a href="/about">关于</a></li>
			        
					</ul>
				</nav>
				<nav class="header-nav">
					<div class="social">
						
							<a class="github" target="_blank" href="https://github.com/mSoloMoon" title="github">github</a>
				        
							<a class="weibo" target="_blank" href="http://t.qq.com/zhengguangyu_msolo" title="weibo">weibo</a>
				        
							<a class="email" target="_blank" href="mailto://yuezhi.msolo@outlook.com" title="email">email</a>
				        
							<a class="qq" target="_blank" href="/212499714" title="qq">qq</a>
				        
					</div>
				</nav>
			</section>
			
			
			<section class="second-part">
				<div class="widget tagcloud">
					<a href="/tags/Android/" style="font-size: 12.50px;">Android</a><a href="/tags/C-C/" style="font-size: 10.00px;">C/C++</a><a href="/tags/Go/" style="font-size: 10.00px;">Go</a><a href="/tags/IT问题录/" style="font-size: 10.00px;">IT问题录</a><a href="/tags/IT面试/" style="font-size: 15.00px;">IT面试</a><a href="/tags/Java/" style="font-size: 12.50px;">Java</a><a href="/tags/Java-Web/" style="font-size: 10.00px;">Java Web</a><a href="/tags/书籍笔记/" style="font-size: 12.50px;">书籍笔记</a><a href="/tags/历史/" style="font-size: 10.00px;">历史</a><a href="/tags/思考/" style="font-size: 12.50px;">思考</a><a href="/tags/摘录/" style="font-size: 10.00px;">摘录</a><a href="/tags/生活记录/" style="font-size: 17.50px;">生活记录</a><a href="/tags/软件开发/" style="font-size: 20.00px;">软件开发</a><a href="/tags/软件框架/" style="font-size: 12.50px;">软件框架</a><a href="/tags/随笔/" style="font-size: 17.50px;">随笔</a><a href="/tags/项目/" style="font-size: 12.50px;">项目</a>
				</div>
			</section>
			
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay"></div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img src="http://msolo-programmer.qiniudn.com/msolo_me_square.png">
			</div>

			<hgroup>
			  <h1 class="header-author"><a href="/">月光独奏</a></h1>
			</hgroup>
			
			<p class="header-subtitle">软件设计及开发者</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/categories/随笔">随笔</a></li>
		        
					<li><a href="/categories/摘录">摘录</a></li>
		        
					<li><a href="/categories/书籍">书籍</a></li>
		        
					<li><a href="/categories/Web">Web</a></li>
		        
					<li><a href="/categories/C-Cpp-Go">C/Cpp/Go</a></li>
		        
					<li><a href="/categories/java-android">Java/Android</a></li>
		        
					<li><a href="/categories/project">Project</a></li>
		        
					<li><a href="/categories/程序员日志">程序员日志</a></li>
		        
					<li><a href="/about">关于</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/mSoloMoon" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://t.qq.com/zhengguangyu_msolo" title="weibo">weibo</a>
			        
						<a class="email" target="_blank" href="mailto://yuezhi.msolo@outlook.com" title="email">email</a>
			        
						<a class="qq" target="_blank" href="/212499714" title="qq">qq</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <article id="post-android-interview-i" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/11/09/android-interview-i/" class="article-date">
  	<time datetime="2014-11-08T18:18:48.000Z" itemprop="datePublished">11月 9 2014</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/java-android/">java-android</a>
  </div>

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/IT面试/">IT面试</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/软件开发/">软件开发</a></li></ul>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Android 面试题纪录
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1-_JVM和DVM的不同">1. JVM和DVM的不同</h3>
<ul>
<li>JVM is a stack-based machine; while DVM is register-based;</li>
<li>A stack-based virtual machine must transfer data from registers to the operand stack before manipulating them. In contrast, a register-based VM operates by directly using virtual registers. This increases the relative size of instructions because they must specify which registers to use, but reduces the number of instructions that must be executed to achieve the same result.</li>
</ul>
<h3 id="2-_Android如何启动一个应用">2. Android如何启动一个应用</h3>
<blockquote>
<p>A special process called the Zygote is launched when Android initially boots. The Zygote starts up a virtual machine, preloads the core libraries, and initializes various shared structures. It then waits for instructions by listening on a socket.</p>
</blockquote>
<ul>
<li>When a new Android application is launched, the Zygote receives a command to create a virtual machine to run the application on. It does this by forking its prewarmed VM process and creating a new child process that shares its memory with the parent, using a technique called Copy-On-Write.</li>
</ul>
<h3 id="3-_UI_Thread_如何工作">3. UI Thread 如何工作</h3>
<p>The UI thread is managed by the platform internal class android.app.ActivityThread.</p>
<blockquote>
<p>By default, any code that we write in our applications will be executed by the main thread.<br>If an app does not respond to user input within 5 seconds, the user will see the Application Not Responding (ANR) dialog and be offered the option to quit the app.<br>Android works hard to synchronize user interface redraws with the hardware refresh rate. This means that it aims to redraw at 60 frames per-second.</p>
</blockquote>
<ul>
<li>Android platform defines its own message passing mechanism for communication between threads. The UI thread can offload long tasks by sending data messages to be processed on background threads. </li>
<li>The message passing mechanism is a nonblocking consumer-producer pattern, where neither the producer thread nor the consumer thread will block during the message handoff. </li>
<li>After API level 16, Android introduced a new entity, the Choreographer, to oversee timing issues. It will start issuing dropped-frame warnings in the log if you drop more than 30 consecutive frames.</li>
<li>The producers can insert new messages in the queue at any time and on any position in the queue.</li>
</ul>
<a id="more"></a>

<p><strong>The UI thread Looper</strong></p>
<ul>
<li>The UI thread is the only thread with an associated Looper by default.</li>
<li>And the Looper is associated with the thread before the application components are initialized.</li>
</ul>
<blockquote>
<p>There are a few practical differences between the UI thread  Looper and other application thread loopers:</p>
<ol>
<li>It is accessible from everywhere, through the Looper.getMainLooper() method.</li>
<li>It cannot be terminated.  Looper.quit() throws  RuntimeException.</li>
<li>The runtime associates a Looper to the UI thread by Looper.prepareMainLooper(). This can be done only once per application. Thus, trying to attach the main looper to another thread will throw an exception.</li>
</ol>
</blockquote>
<p><strong>Communicating with the UI Thread</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Runnable task = <span class="keyword">new</span> Runnable() {...};</div><div class="line"><span class="keyword">new</span> Handler(Looper.getMainLooper()).post(task);</div><div class="line"><span class="comment">// Method called on UI thread.</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postFromUiThreadToUiThread</span>() {</div><div class="line">    <span class="keyword">new</span> Handler().post(<span class="keyword">new</span> Runnable() { ... });</div><div class="line">    <span class="comment">// The code at this point is part of a message being processed and is executed before the posted message.</span></div><div class="line">}</div><div class="line"><span class="comment">// Method called on UI thread.</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postFromUiThreadToUiThread</span>() {</div><div class="line">    runOnUiThread(<span class="keyword">new</span> Runnable() { ... });</div><div class="line">		<span class="comment">// The code at this point is executed after the message.</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>如何查看 UI Thread</strong></p>
<p>Below named com.eat is started by default when the application launches. Hence, that is the UI thread of the application.  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ adb shell ps -t | grep u0_a72</div><div class="line">USER      PID   PPID  VSIZE  RSS   WCHAN    PS         NAME</div><div class="line">u0_a72    <span class="number">4257</span>  <span class="number">144</span>   <span class="number">320304</span> <span class="number">34540</span> ffffffff <span class="number">00000000</span> S com.eat</div><div class="line">u0_a72    <span class="number">4259</span>  <span class="number">4257</span>  <span class="number">320304</span> <span class="number">34540</span> ffffffff <span class="number">00000000</span> S GC</div><div class="line">u0_a72    <span class="number">4262</span>  <span class="number">4257</span>  <span class="number">320304</span> <span class="number">34540</span> ffffffff <span class="number">00000000</span> S Signal Catcher</div><div class="line">u0_a72    <span class="number">4263</span>  <span class="number">4257</span>  <span class="number">320304</span> <span class="number">34540</span> ffffffff <span class="number">00000000</span> S JDWP</div><div class="line">u0_a72    <span class="number">4264</span>  <span class="number">4257</span>  <span class="number">320304</span> <span class="number">34540</span> ffffffff <span class="number">00000000</span> S Compiler</div><div class="line">u0_a72    <span class="number">4265</span>  <span class="number">4257</span>  <span class="number">320304</span> <span class="number">34540</span> ffffffff <span class="number">00000000</span> S ReferenceQueueDemon</div><div class="line">u0_a72    <span class="number">4266</span>  <span class="number">4257</span>  <span class="number">320304</span> <span class="number">34540</span> ffffffff <span class="number">00000000</span> S FinalizerDaemon</div><div class="line">u0_a72    <span class="number">4267</span>  <span class="number">4257</span>  <span class="number">320304</span> <span class="number">34540</span> ffffffff <span class="number">00000000</span> S FinalizerWatchdogDaemon</div><div class="line">u0_a72    <span class="number">4268</span>  <span class="number">4257</span>  <span class="number">320304</span> <span class="number">34540</span> ffffffff <span class="number">00000000</span> S Binder_1</div><div class="line">u0_a72    <span class="number">4269</span>  <span class="number">4257</span>  <span class="number">320304</span> <span class="number">34540</span> ffffffff <span class="number">00000000</span> S Binder_2</div></pre></td></tr></table></figure>



<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">### 4. UI Thread 消息机制 API 概览 ###</span></div><div class="line"></div><div class="line">&gt; android.os.Handler: Consumer thread message processor, <span class="operator">and</span> <span class="operator">the</span> interface <span class="keyword">for</span> <span class="operator">a</span> producer thread <span class="built_in">to</span> insert messages <span class="keyword">into</span> <span class="operator">the</span> queue. A Looper can have many associated handlers, but they all insert messages <span class="keyword">into</span> <span class="operator">the</span> same queue.</div><div class="line">&gt; android.os.Looper: A message dispatcher associated <span class="operator">with</span> <span class="operator">the</span> <span class="constant">one</span> <span class="operator">and</span> only consumer thread.</div><div class="line">&gt; android.os.MessageQueue: Unbounded linked list <span class="operator">of</span> messages <span class="built_in">to</span> be processed <span class="command"><span class="keyword">on</span> <span class="title">the</span> <span class="title">consumer</span> <span class="title">thread</span>. <span class="title">Every</span> <span class="title">Looper</span>—<span class="title">and</span> <span class="title">Thread</span>—<span class="title">has</span> <span class="title">at</span> <span class="title">most</span> <span class="title">one</span>  <span class="title">MessageQueue</span>.</span></div><div class="line">&gt; android.os.Message: Message <span class="built_in">to</span> be executed <span class="command"><span class="keyword">on</span> <span class="title">the</span> <span class="title">consumer</span> <span class="title">thread</span>.</span></div><div class="line"></div><div class="line">![message-passing机制概览](<span class="keyword">https</span>://msolomoon.github.io/images/the_ui_thread_message_passing_api.png)</div><div class="line"></div><div class="line">- Insert: The producer thread inserts messages <span class="operator">in</span> <span class="operator">the</span> queue <span class="keyword">by</span> <span class="keyword">using</span> <span class="operator">the</span> Handler connected <span class="built_in">to</span> <span class="operator">the</span> consumer thread.</div><div class="line">- Retrieve: The  Looper, runs <span class="operator">in</span> <span class="operator">the</span> consumer thread <span class="operator">and</span> retrieves messages <span class="built_in">from</span> <span class="operator">the</span> queue <span class="operator">in</span> <span class="operator">a</span> sequential order.</div><div class="line">- Dispatch: The handlers are responsible <span class="keyword">for</span> processing <span class="operator">the</span> messages <span class="command"><span class="keyword">on</span> <span class="title">the</span> <span class="title">consumer</span> <span class="title">thread</span>. <span class="title">A</span> <span class="title">thread</span> <span class="title">may</span> <span class="title">have</span> <span class="title">multiple</span> <span class="title">Handler</span> <span class="title">instances</span> <span class="title">for</span> <span class="title">processing</span> <span class="title">messages</span>; <span class="title">the</span> <span class="title">Looper</span> <span class="title">ensures</span> <span class="title">that</span> <span class="title">messages</span> <span class="title">are</span> <span class="title">dispatched</span> <span class="title">to</span> <span class="title">the</span> <span class="title">correct</span> <span class="title">Handler</span>.</span></div></pre></td></tr></table></figure>

<p> java<br>// 示例: Basic Message Passing<br>public class LooperActivity extends Activity {<br>    LooperThread mLooperThread;<br>    private static class LooperThread extends Thread { // for inserting messages in the queue<br>        public void run() {<br>            Looper.prepare();<br>            mHandler = new Handler() {<br>                public void handleMessage(Message msg) {<br>                    if(msg.what == 0) { doLongRunningOperation(); }<br>                }<br>            };<br>            // Start dispatching messages from the message queue to the consumer thread.<br>            // This is a blocking call, so the worker thread will not finish.<br>            Looper.loop();<br>        }<br>    }<br>    public void onCreate(Bundle savedInstanceState) {<br>        super.onCreate(savedInstanceState);<br>        mLooperThread = new LooperThread();<br>        mLooperThread.start();<br>    }<br>    public void onClick(View v) {<br>        if (mLooperThread.mHandler != null) {<br>            Message msg = mLooperThread.mHandler.obtainMessage(0);<br>            mLooperThread.mHandler.sendMessage(msg); // Insert the message in the queue.<br>        }<br>    }<br>    private void doLongRunningOperation() {<br>        // Add long running operation here.<br>    }<br>    protected void onDestroy() {<br>        mLooperThread.mHandler.getLooper().quit(); // Terminate the background thread.<br>    }<br>} </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">### 5. 阐述 MessageQueue.IdleHandler ###</span></div><div class="line"></div><div class="line">&gt; If there <span class="keyword">is</span> no message <span class="keyword">to</span> process, a consumer thread has <span class="keyword">some</span> idle <span class="property">time</span>. Instead <span class="keyword">of</span> waiting, <span class="keyword">the</span> thread can be utilized <span class="keyword">to</span> execute other tasks during these idle slots. </div><div class="line">&gt; When <span class="keyword">the</span> message queue detects idle <span class="property">time</span> <span class="keyword">for</span> <span class="keyword">the</span> consumer thread, <span class="keyword">it</span> invokes queueIdle() <span class="function_start"><span class="keyword">on</span></span> all registered IdleHandler-instances. It <span class="keyword">is</span> up <span class="keyword">to</span> <span class="keyword">the</span> <span class="type">application</span> <span class="keyword">to</span> implement <span class="keyword">the</span> callback responsibly. You should usually avoid long-<span class="property">running</span> tasks because they will <span class="command">delay</span> pending messages during <span class="keyword">the</span> <span class="property">time</span> they <span class="command">run</span>.</div></pre></td></tr></table></figure>

<p> java<br>// Get the message queue of the current thread.<br>MessageQueue mq = Looper.myQueue();<br>// Create and register an idle listener.<br>MessageQueue.IdleHandler idleHandler = new MessageQueue.IdleHandler();<br>mq.addIdleHandler(idleHandler)<br>// Unregister an idle listener.<br>mq.removeIdleHandler(idleHandler)</p>
<p>interface IdleHandler {<br>    boolean queueIdle();<br>}<br>// The implementation of queueIdle() must return a Boolean value with the following meanings:<br>// true: The idle handler is kept active; it will continue to receive callbacks for successive idle time slots.<br>// false: The idle handler is inactive; it will not receive anymore callbacks for successive idle time  slots.<br>// This is the same thing as removing the listener through Message Queue.removeIdleHandler().</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">### 6. Android 平台如何调度线程 ###</span></div><div class="line"></div><div class="line">**Priority**：Change <span class="operator">the</span> Linux thread priority.</div><div class="line"></div><div class="line">- java.lang.Thread: </div><div class="line">- setPriority(int priority);<span class="comment">	// from 0 (least prioritized) to 10 (most prioritized).</span></div><div class="line">- android.os.Process</div><div class="line">- Process.setThreadPriority(int priority);<span class="comment"> // Calling thread.</span></div><div class="line">- Process.setThreadPriority(int threadId, int priority);<span class="comment">	// Thread with specific id.</span></div><div class="line"></div><div class="line">**Control group**： Change <span class="operator">the</span> Android-specific control group.  </div><div class="line"></div><div class="line">- Android defines multiple control groups, but <span class="operator">the</span> most important ones <span class="keyword">for</span> applications are <span class="operator">the</span> Foreground Group <span class="operator">and</span> Background Group.</div><div class="line">- The threads created <span class="keyword">by</span> <span class="operator">the</span> application <span class="keyword">by</span> default have <span class="operator">the</span> same priority <span class="operator">and</span> control group membership <span class="keyword">as</span> <span class="operator">the</span> UI thread, so they compete <span class="command"><span class="keyword">on</span> <span class="title">equal</span> <span class="title">terms</span> <span class="title">for</span> <span class="title">processor</span> <span class="title">allocation</span>.</span></div><div class="line">- To solve problem that lots <span class="operator">of</span> background threads may reduce <span class="operator">the</span> performance <span class="operator">of</span> <span class="operator">the</span> UI thread, <span class="keyword">it</span>’s possible <span class="built_in">to</span> decouple background threads <span class="built_in">from</span> <span class="operator">the</span> control group where <span class="operator">the</span> application threads execute <span class="keyword">by</span> default.</div><div class="line">- Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND)</div></pre></td></tr></table></figure>

<p> bash<br>$ adb shell ps -P | grep u0_a72        # show foreground thread<br>u0_a72    4257  144   320304 34504 fg  ffffffff 00000000 S com.eat</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">### 7. Android下线程有哪些通信方式 ###</span></div><div class="line"></div><div class="line"><span class="keyword">*</span><span class="keyword">*</span>Pipe<span class="keyword">*</span><span class="keyword">*</span></div></pre></td></tr></table></figure>

<p> java<br>int BUFFER_SIZE_IN_CHARS = 1024 * 4;<br>PipedReader r = new PipedReader(BUFFER_SIZE_IN_CHARS);    // default is 1024<br>PipedWriter w = new PipedWriter(r);<br>Thread t = new MyReaderThread(r);<br>t.start();<br>// Producer thread: Flush the pipe after a write.<br>w.write(‘A’);<br>w.flush();<br>// Consumer thread: Read the data in a loop.<br>int i;<br>// when the buffer is empty, the PipedReader uses a blocking call to wait() with one-second timeout.<br>while((i = reader.read()) != -1){<br>    char c = (char) i;<br>}<br>//<br>w.close();<br>r.close();</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">*</span><span class="keyword">*</span>Shared Memory<span class="keyword">*</span><span class="keyword">*</span></div><div class="line"></div><div class="line"><span class="keyword">*</span><span class="keyword">*</span>Signaling<span class="keyword">*</span><span class="keyword">*</span>（be considered as the most error-prone technique）</div><div class="line"></div><div class="line">- 1. synchronized: Object.wait() / Object.wait(timeout); Object.notify() / Object.notifyAll()</div><div class="line">- 2. ReentrantLock: Condition.await() / Condition.await(timeout); Condition.signal() / Condition.signalAll()</div><div class="line">- 3. ReentrantReadWriteLock: Condition.await() / Condition.await(timeout); Condition.signal() / Condition.signalAll() </div><div class="line"></div><div class="line"><span class="keyword">*</span><span class="keyword">*</span>BlockingQueue<span class="keyword">*</span><span class="keyword">*</span></div></pre></td></tr></table></figure>

<p> java<br>public class ConsumerProducer {<br>    private final int LIMIT = 10;<br>    private BlockingQueue<integer> blockingQueue = new LinkedBlockingQueue<integer>(LIMIT);<br>    public void produce() throws InterruptedException {<br>        int value = 0;<br>        while (true) {<br>            blockingQueue.put(value++);<br>        }<br>    }<br>    public void consume() throws InterruptedException {<br>        while (true) {<br>            int value = blockingQueue.take();<br>        }<br>    }<br>}</integer></integer></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">**Android <span class="keyword">Message</span> Passing**（参考第<span class="number">4</span>题）</div><div class="line"></div><div class="line">- The lifecycle <span class="keyword">of</span> a <span class="keyword">message</span>: create<span class="comment">(**initialized**)</span> -&gt; enqueue<span class="comment">(**pending**)</span> -&gt; dispatch<span class="comment">(**dispatched**)</span> -&gt; recycle<span class="comment">(**recycled**)</span> -&gt; <span class="comment">(**initialized**)</span></div><div class="line"></div><div class="line">&gt; <span class="keyword">Message</span> creation API:</div><div class="line">&gt; <span class="keyword">Message</span> m  = new <span class="keyword">Message</span>();</div><div class="line">&gt; <span class="keyword">Message</span> m = <span class="keyword">Message</span>.obtain();	<span class="comment">// empty message</span></div><div class="line">&gt; <span class="keyword">Message</span> m = <span class="keyword">Message</span>.obtain(Handler h);</div><div class="line">&gt; <span class="keyword">Message</span> m = <span class="keyword">Message</span>.obtain(Handler h, int what);</div><div class="line">&gt; <span class="keyword">Message</span> m = <span class="keyword">Message</span>.obtain(Handler h, int what, <span class="keyword">Object</span> o);</div><div class="line">&gt; <span class="keyword">Message</span> m = <span class="keyword">Message</span>.obtain(Handler h, int what, int arg1, int arg2);</div><div class="line">&gt; <span class="keyword">Message</span> m = <span class="keyword">Message</span>.obtain(Handler h, int what, int arg1, int arg2, <span class="keyword">Object</span> o);</div><div class="line">&gt; <span class="keyword">Message</span> m = <span class="keyword">Message</span>.obtain(Handler h, Runnable task);	<span class="comment">// task message</span></div><div class="line">&gt; <span class="keyword">Message</span> m = <span class="keyword">Message</span>.obtain(<span class="keyword">Message</span> originalMsg); <span class="comment">// copy constructor</span></div><div class="line"></div><div class="line">Handler</div><div class="line"></div><div class="line">- Setup</div><div class="line">- Constructors without an explicit Looper bind <span class="keyword">to</span> the Looper <span class="keyword">of</span> the current thread: new Handler(); 或	new Handler(Handler.Callback)</div><div class="line">- Constructors <span class="keyword">with</span> an explicit  Looper bind <span class="keyword">to</span> that  Looper: new Handler(Looper); 或 new Handler(Looper, Handler.Callback);</div><div class="line">- <span class="keyword">Message</span> creation (参考上面)</div><div class="line">- <span class="keyword">Message</span> insertion,  The sorting is based <span class="keyword">on</span> the time parameter, <span class="keyword">and</span> it is the only way an application can affect the dispatch order: <span class="keyword">default</span>（Immediately eligible <span class="keyword">for</span> dispatch），at_front（dispatch at time <span class="number">0</span>. Hence, it will be the next dispatched <span class="keyword">message</span>, unless another is inserted at the front before this one is processed）, delay（The amount <span class="keyword">of</span> time after which this <span class="keyword">message</span> is eligible <span class="keyword">for</span> dispatch），uptime（The absolute time at which this <span class="keyword">message</span> is eligible <span class="keyword">for</span> dispatch）</div></pre></td></tr></table></figure>

<p> java<br>// Add a task to the message queue:<br>boolean post(Runnable r)<br>boolean postAtFrontOfQueue(Runnable r)<br>boolean postAtTime(Runnable r, Object token, long uptimeMillis)<br>boolean postAtTime(Runnable r, long uptimeMillis)<br>boolean postDelayed(Runnable r, long delayMillis)<br>// Add a data object to the message queue:<br>boolean sendMessage(Message msg)<br>boolean sendMessageAtFrontOfQueue(Message msg)<br>boolean sendMessageAtTime(Message msg, long uptimeMillis)<br>boolean sendMessageDelayed(Message msg, long delayMillis)<br>// Add simple data object to the message queue:<br>boolean sendEmptyMessage(int what)<br>boolean sendEmptyMessageAtTime(int what, long uptimeMillis)<br>boolean sendEmptyMessageDelayed(int what, long delayMillis)<br>//<br>// Message insertion errors<br>// RuntimeException: Message has no Handler; Message has already been dispatched and is being processed.<br>// Return false: Message is inserted after Looper.quit() has been called.<br>//<br>// example 1<br>private class BackgroundThread extends Thread {<br>    private Handler mBackgroundHandler;<br>    public void run() {<br>        Looper.prepare();<br>        mBackgroundHandler = new Handler();<br>        Looper.loop();<br>    }<br>    public void doWork() {<br>        mBackgroundHandler.post(new Runnable() {<br>                @Override<br>                public void run() {<br>                        Message uiMsg = mUiHandler.obtainMessage(SHOW_PROGRESS_BAR, 0, 0, null);<br>                        mUiHandler.sendMessage(uiMsg);<br>                        Random r = new Random();<br>                        int randomInt = r.nextInt(5000);<br>                        SystemClock.sleep(randomInt);<br>                        uiMsg = mUiHandler.obtainMessage(HIDE_PROGRESS_BAR, randomInt, 0, null);<br>                        mUiHandler.sendMessage(uiMsg);<br>                }<br>        });<br>    }<br>    public void exit() {<br>        mBackgroundHandler.getLooper().quit();<br>    }<br>}<br>private final Handler mUiHandler = new Handler() {<br>    public void handleMessage(Message msg) {<br>        switch(msg.what) {<br>            case SHOW_PROGRESS_BAR:<br>                mProgressBar.setVisibility(View.VISIBLE);<br>                break;<br>            case HIDE_PROGRESS_BAR:<br>                mText.setText(String.valueOf(msg.arg1));<br>                mProgressBar.setVisibility(View.INVISIBLE);<br>                break;<br>        }<br>    }<br>};<br>// example 2<br>public class HandlerCallbackActivity extends Activity implements Handler.Callback {<br>    @Override<br>    public boolean handleMessage(Message msg) {<br>        switch (msg.what) {<br>            case 1:<br>                msg.what = 11;<br>                return true;<br>            default:<br>                msg.what = 22;<br>                return false;<br>        }<br>    }<br>    public void onHandlerCallback(View v) {<br>        Handler handler = new Handler(this) {<br>            @Override<br>            public void handleMessage(Message msg) {<br>                // Process message<br>            }<br>        };<br>        handler.sendEmptyMessage(1);<br>        handler.sendEmptyMessage(2);<br>    }<br>}</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- Removing Messages <span class="built_in">from</span> <span class="operator">the</span> Queue</div></pre></td></tr></table></figure>

<p> java<br>// Remove a task from the message queue<br>removeCallbacks(Runnable r)<br>removeCallbacks(Runnable r, Object token)<br>// Remove a data message from the message queue<br>removeMessages(int what)<br>removeMessages(int what, Object object)<br>// Remove tasks and data messages from the message queue<br>removeCallbacksAndMessages(Object token)<br>// Taking a snapshot of the current message queue<br>mWorkerHandler.dump(new LogPrinter(Log.DEBUG, TAG), “”);<br>// Tracing the message queue processing<br>Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, TAG));<br>```</p>
<h3 id="8-_进程间如何通信">8. 进程间如何通信</h3>
<p><strong>Android RPC</strong></p>
<ul>
<li>IPC is managed by the Linux OS, which supports several IPC techniques: signals, pipes, message queues, semaphores, and shared memory. </li>
<li>In Android’s modified Linux kernel, the Linux IPC techniques have been replaced by the binder framework, which enables<br>an RPC mechanism between processes; </li>
</ul>
<blockquote>
<p>RPC mechanism consists of the following steps:</p>
<ol>
<li>Method and data decomposition, also known as marshalling</li>
<li>Transferring the marshalled information to the remote process</li>
<li>Recomposing the information in the remote process, also known as unmarshalling</li>
<li>Transferring return values back to the originating process</li>
</ol>
</blockquote>
<p><strong>Binder</strong></p>
<p><img src="https://msolomoon.github.io/images/IPC_through_Binder.png" alt="IPC through binder"></p>
<ul>
<li>The client thread calling transact is blocked by default until onTransact has finished executing on the remote thread. </li>
<li>Transaction data consists of android.os.Parcel objects, which are optimized to be sent across processes via the Binder.</li>
<li>The  onTransact method is executed on a thread from a pool of binder threads. This pool exists only to handle incoming requests from other processes. It has a maximum of 16 threads</li>
<li>IPC can be bidirectional.</li>
</ul>
<p><strong>AIDL（Android Interface Definition Language）</strong></p>
<p><img src="https://msolomoon.github.io/images/AIDL_remote _procedure.png" alt="AIDL remote procedure"></p>
<ul>
<li>The generated Java interface is included in all the client applications and in the server application. The interface file defines two inner classes,  Proxy and  Stub, that handle all the marshalling and unmarshalling of the data, as well as the transaction itself. </li>
</ul>
<p><strong>未完待续</strong></p>

      
    </div>
    <footer class="article-footer">
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2014/11/09/begin-hello-world/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">&lt;</strong>
      <div class="article-nav-title">
        
          程序员的自我修养 - 从Hello World！说起
        
      </div>
    </a>
  
  
    <a href="/2014/11/08/project-stockeye-package-calendarstock/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Stockeye项目 - CalendarStock包（初步设计）</div>
      <strong class="article-nav-caption">&gt;</strong>
    </a>
  
</nav>

  
</article>


<div class="share">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到：</span>
		<a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
		<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>



<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="android-interview-i" data-title="Android 面试题纪录" data-url="http://yoursite.com/2014/11/09/android-interview-i/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2014 月光独奏
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">

  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>

  <script src="/js/main.js" type="text/javascript"></script>


  </div>
</body>
</html>